---
layout: post
title: Python & C++ Rosalind prot - Translating RNA into Protein
category: Rosalind
---

[http://rosalind.info/problems/prot/](http://rosalind.info/problems/prot/)

### 배경

DNA가 전사되면 mRNA가 되고, 그 다음은 번역(translation)을 거쳐 20가지 아미노산의 서열로 이루어진 단백질 분자가 된다. 단백질이 되어야 보통 유전자가 기능을 갖는다고 표현한다. 따라서 DNA 서열이 있으면 RNA를 거쳐 단백질 서열로 번역할 수 있어야 한다.

RNA 서열의 순차적으로 3개의 염기가 아미노산 1개가 된다. 4개의 염기가 3개의 조합을 이루는 경우의 수는 64개, 이 64개의 조합이 중복을 허용해서 20개의 아미노산이 될 수 있기 때문에, 마치 암호를 해독하는 것과 같다고 해서 3개 조합의 염기를 코돈(codon)이라고 한다.

```
RNA:  AUG GCC AUG GCG CCC AGA ACU GAG AUC AAU AGU ACC CGU AUU AAC GGG UGA
PROT:  M   A   M   A   P   R   T   E   I   N   S   T   R   I   N   G   *
```

<!--description-->

코돈 중에서 ATG, UAA, UGA, UAG 서열은 특별하다. ATG 서열 a.k.a. start codon은 Methionine 아미노산을 코딩하는데, 모든 단백질은 Methionine부터 시작하므로, DNA 서열에서 ATG가 나오는 곳에서부터 번역이 시작된다. 다른 세 서열 a.k.a. stop codon은 아무 아미노산도 코딩하지 않는다. 즉 이 세 서열이 등장하면 번역이 끝나고, 단백질은 딱 여기까지만 만들어진다.

### 알고리즘

DNA 서열을 받으면 반복문을 돌며 3개 염기씩 끊어서 아미노산으로 변환해 새로운 문자열을 만든다. 미리 DNA 코돈 당 아미노산을 담는 map 또는 dictionary table을 만들어둔다. Stop codon이 나오면 번역이 끝나므로 반복문을 나온다.

### 코딩

일단 codon table을 만들 때 노가다에 상당히 화가 난다. 그리고 반복문을 돌 때 3개 문자씩 끊다보면 맨 마지막 문자가 남는 경우가 있어 index error가 나지 않게끔 주의해야 한다. 다만 잘만 코딩한다면 파이썬은 내가 한 것보다 훨씬 예쁘게 짤 수 있을 것이다.

C++은 dictionary가 map으로 되어있기 때문에, 서식이 또 다르다. map.find() 함수를 실행하면 map의 몇 번째 순서에 해당 코돈이 위치하는지 iterator 객체를 반환하므로, 해당 객체의 second가 아미노산이다. 자세한 내용은 ***[https://life-with-coding.tistory.com/305](https://life-with-coding.tistory.com/305)*** 참조.

### 솔루션

#### Python

```py
def prot(s):
    """Translating RNA into Protein"""
    codon_table = {
        "UUU": "F",
        # ...
        "GGG": "G",
    }
    protein = ""
    for i in range(len(s))[::3]:
        frame = s[i : i + 3]
        if len(frame) == 3:
            aa = codon_table[s[i : i + 3]]
            if aa == 'Stop':
                break
            protein += aa
    return protein
```

#### C++

```c++
PROT RNA::translate() {
  using std::map;

  map<string, char> codon_table = {
    {"AAA", 'K'}, {"AAG", 'K'}, {"AAC", 'N'}, {"AAU", 'N'},
    {"AGA", 'R'}, {"AGG", 'R'}, {"AGC", 'S'}, {"AGU", 'S'},
    {"ACA", 'T'}, {"ACG", 'T'}, {"ACC", 'T'}, {"ACU", 'T'},
    {"AUA", 'I'}, {"AUG", 'M'}, {"AUC", 'I'}, {"AUU", 'I'},
    {"CAA", 'Q'}, {"CAG", 'Q'}, {"CAC", 'H'}, {"CAU", 'H'},
    {"CGA", 'R'}, {"CGG", 'R'}, {"CGC", 'R'}, {"CGU", 'R'},
    {"CCA", 'P'}, {"CCG", 'P'}, {"CCC", 'P'}, {"CCU", 'P'},
    {"CUA", 'L'}, {"CUG", 'L'}, {"CUC", 'L'}, {"CUU", 'L'},
    {"UAA", '*'}, {"UAG", '*'}, {"UAC", 'Y'}, {"UAU", 'Y'},
    {"UGA", '*'}, {"UGG", 'W'}, {"UGC", 'C'}, {"UGU", 'C'},
    {"UCA", 'S'}, {"UCG", 'S'}, {"UCC", 'S'}, {"UCU", 'S'},
    {"UUA", 'L'}, {"UUG", 'L'}, {"UUC", 'F'}, {"UUU", 'F'},
    {"GAA", 'E'}, {"GAG", 'E'}, {"GAC", 'D'}, {"GAU", 'D'},
    {"GGA", 'G'}, {"GGG", 'G'}, {"GGC", 'G'}, {"GGU", 'G'},
    {"GCA", 'A'}, {"GCG", 'A'}, {"GCC", 'A'}, {"GCU", 'A'},
    {"GUA", 'V'}, {"GUG", 'V'}, {"GUC", 'V'}, {"GUU", 'V'},
  };

  string prot_sequence;
  for (int idx = 0; idx < sequence_.length() / 3; idx++) {
    prot_sequence += codon_table.find(sequence_.substr(idx * 3, 3))->second;
  }

  return PROT(prot_sequence);
}
```