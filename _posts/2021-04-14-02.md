---
layout: post
title: Python & C++ Rosalind revc - Complementing a Strand of DNA
category: Rosalind
---

[http://rosalind.info/problems/revc/](http://rosalind.info/problems/revc/)

### 배경

유전 정보는 엄밀히 말하자면 DNA 두 분자가 한 단위이다. DNA 두 분자는 서로 상보적이다. 상보적이라는 말은, 한 분자에서 각각 염기가 A, G일 때 맞은편 분자에서는 염기가 T, C라는 것이다. 따라서 DNA 한 분자가 ATCG면, 맞은편 분자는 TAGC의 서열을 갖는다.

하지만 엄밀히 말하자면 맞은편 분자의 서열은 TAGC가 아니라 GCTA이다. DNA는 5'이라는 말단에서 3'이라는 말단으로 향하는 방향성을 갖기 때문이다. DNA 한 분자가 5'-ATCG-3'이면, 맞은편 분자는 3'-TAGC-5', 즉 5'-GCTA-3'이다.

<!--description-->

```
5'-ATCG-3'
   ||||    <- 염기간 수소결합
3'-TAGC-5'
```

이 때 DNA 한 분자와 다른 분자를 서로 reverse complementary하다고 표현한다. DNA 한 분자의 서열을 알면, 상보적인 분자의 서열을 알 수 있다.

### 알고리즘

문자열이 들어오면 상보적인 문자를 다른 문자열에 집어넣은 뒤 뒤집어준다.

### 코딩

파이썬도 사실 이 정도쯤 되면 한 줄로 코딩이 안된다. 다만, rosalind에 가서 문제를 풀고 솔루션 탭을 열어보아라. 이걸 굳이 한 줄로 푼 사람이 있다. Pythonic하지 않기 때문에, 즉 명시적이지 않기 때문에 좋은 코드라 할 순 없지만...

C++에선 처음에 string을 input 길이로 지정해두고 반복문을 돌면서 index마다 바꾸려고 했는데, 아마 string은 index로 참조해서 바꾸는게 안되는 것 같다. 포인터 쓰면 되는 것 같은데 굳이 그럴 문제까지는 아닌 것 같고.

그래서 char array 만들고, 같은 방식으로 반복문에서 index마다 바꾼 다음 마지막에 array 원소를 뒤집은 string을 만들었다. ~~이 때부터 복잡해져서 기분이 살짝 나빠짐...~~

생각해보니 array할 필요 없이 string을 빈 채로 초기화하고 하나씩 붙여주면 되는 거였다...멍청

역시 검색해보니 `algorithm::reverse`도 있었다. algorithm 라이브러리 그는 신인가?

### 솔루션

#### Python

```python
def main():
    s = input()
    sc = str()
    for nt in s:
        if nt == "A":
            sc += "T"
        elif nt == "T":
            sc += "A"
        elif nt == "C":
            sc += "G"
        elif nt == "G":
            sc += "C"
    print(sc[::-1])
```

#### C++

```c++
// Copyright 2021 panda5176
#include <iostream>

int main() {
  std::string s;
  std::cin >> s;

  const int SLen = s.length();
  char sc_array[SLen];
  for (int i = 0; i < SLen; i++) {
    switch (s[i]) {
      case 'A': {
        sc_array[i] = 'T';
        break;
      }
      case 'T': {
        sc_array[i] = 'A';
        break;
      }
      case 'G': {
        sc_array[i] = 'C';
        break;
      }
      case 'C': {
        sc_array[i] = 'G';
        break;
      }
    }
  }

  std::string sc;
  for (int i = 0; i <= SLen; i++) {
    sc += sc_array[SLen - i - 1];
  }
  // 혹은
  std::reverse(sc.begin(), sc.end());

  std::cout << sc << std::endl;

  return 0;
}
```
