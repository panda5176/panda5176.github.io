---
layout: post
title: Python & C++ Rosalind fib - Rabbits and Recurrence Relations
category: Rosalind
---

[http://rosalind.info/problems/fib/](http://rosalind.info/problems/fib/)

### 배경

~~유전학에서 자주 사용되는 개념은 아니지만,~~ 토끼가 성숙하는데 1년이 걸리고, 성숙한 토끼는 절대 죽지 않고 1마리의 아기 토끼를 낳는다고 가정해보자. 이를테면 다음과 같이.

```
1년차) 미성숙 토끼 1마리 = 총 1마리
2년차) 성숙 토끼 1마리 = 총 1마리
3년차) 성숙 토끼 1마리, (성숙 토끼가 낳은) 미성숙 토끼 1마리 = 총 2마리
4년차) 성숙토끼 2마리, (이미 성숙했던 토끼가 낳은) 미성숙 토끼 1마리 = 총 3마리
5년차) 성숙토끼 3마리, (이미 성숙했던 토끼가 낳은) 미성숙 토끼 2마리 = 총 5마리
```

<!--description-->

이런 식으로, 토끼의 해마다 숫자를 세보면, 1-1-2-3-5-8-13-... 피보나치 수열을 이룬다.

`F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1`

토끼가 늘 일정한 숫자의 아기토끼를 낳는다고 가정하면, 예제에서처럼 성숙 토끼가 낳는 마릿수가 k로 주어졌을 때 n년차 후의 토끼 수를 구할 수 있다.

### 알고리즘

`1-1-(1+1k)-((1+1k)+1k)-((1+2k)+(1+1k)k)-...`

`F(n) = F(n-1) + kF(n-2)`

재귀함수로 푸는 방법이 코드 자체는 제일 간단하지만, 그냥 반복문 돌려서 memoization으로 풀어도 된다. 그게 메모리도 덜듬.

어려운 내용이고 나보다 잘 설명해준 사람이 있으니, 자세한 내용은 [Memoization. 피보나치 수열을 통해 반복문, 재귀함수와 비교하기](https://velog.io/@minjae-mj/Memoization-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-feat.-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4) 참고.

### 코딩

역시나 파이썬은 우리를 배신하지 않는다. 매우 짧게 코딩이 가능. Infant(미성숙), mature(성숙), new_born(새로 낳음)으로 나누어 계산하면, generation(세대)에 따라 다음과 같다.

```
genen    0 1 2 3 4
new_born 0 0 3 3 12
infant   1 0 3 3 12
mature   0 1 1 4 7
total    1 1 4 7 19
```

C++에서는 구현하면서 결과 토끼의 숫자 크기가 너무 커졌는데, 그래서 long long int를 쓰려고 했더니 구글 스타일 가이드에서 비추천이라고 한다. 알고보니 OS에 따라서 long int나 long long int에 배정되는 메모리양이 다르다고 한다. 나는 64bit를 쓰고싶어도, OS에 따라서 32bit로 할당하기도 한다나봄.

그래서 `cstdint::int64_t`를 사용해서 long long int를 쓰기로 했다. 

### 솔루션

#### Python

```python
def main():
    n = input()
    k = input()

    infant, mature, total = 1, 0, 1
    for _ in range(n - 1): # _: generation
        new_born = mature * k
        mature += infant
        infant = new_born

    total = infant + mature
    print(total)
```

#### C++

```c++
// Copyright 2021 panda5176
#include <cstdint>
#include <iostream>

int main() {
  int n;
  int k;
  std::cin >> n;
  std::cin >> k;

  int64_t infant = 1, mature = 0, total = 1;
  for (int generation = 1; generation < n; generation++) {
    int64_t new_born = mature * k;
    mature += infant;
    infant = new_born;
  }
  total = infant + mature;

  std::cout << total << std::endl;

  return 0;
}
```
