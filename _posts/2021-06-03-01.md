---
layout: post
title: Python & C++ Rosalind iprb - Mendel's First Law
category: Rosalind
---

[http://rosalind.info/problems/iprb/](http://rosalind.info/problems/iprb/)

### 배경

유전학에서 한 쌍의 상보적인 DNA는 하나의 염색체를 이룬다. 한 쌍의 염색체, a.k.a. 상동염색체는 23쌍이 모여 인간 유전 정보를 구성한다. 따라서 간단히 보자면 인간의 유전 정보는 DNA 46개 분자로 구성된다고도 할 수 있다.

하나의 염색체에는 수천 개의 유전자가 들어있곤 하지만, 염색체는 한 쌍을 이루므로 모든 사람은 한 유전자를 두 개씩 가지고 있다고도 할 수 있다. 이 때 각 유전자는 돌연변이가 각각 일어나서 서로 다른 서열이 될 수 있는데, 한 유전자의 서로 다른 서열을 allele이라고 한다. ~~알렐레 아니고 얼리얼~~

<!--description-->

한 쌍의 allele이 같으면 homozygous(동형), 다르면 heterozygous(이형)이라고 하는데, 질병 등의 형질 중에 동형이어야 겉으로 표현되는 것이 있고, 이형이어야 표현되는 것이 있다. 동형이어야지만 겉으로 표현되는 것을 recessive(열성) 형질이라고 하고, 이형이어도 겉으로 표현되는 것을 dominant(열성) 형질이라고 한다.

그리고 멘델의 유전법칙에 따라 부모가 아기를 낳을 때 한 쌍의 allele은 서로 떨어져서 둘 중의 하나가 랜덤하게 아이에게 가고, 부모의 각 allele이 모여서 아이의 한 쌍의 allele을 구성하기 때문에 부모가 질병이 있어도 아기가 있을지는 계산을 해봐야 아는 것이다.

### 알고리즘

쉽게 말해 k, m, n 세 숫자가 들어오는데, k는 동형 우성, m은 이형, n은 동형 열성인 부모의 숫자일 때 부모 세대를 랜덤하게 교배했을 경우 자식이 우성 표현형이 나타날 확률은? 이란 문제다.

~~문제가 조금 길어서 난독증이 올뻔했다~~ 쉽지 않다고? ㅋㅋㅋ 나도 헷갈린다. 다시 자세히 들여다보자.

A allele이 우성 형질로 나타나는 질병이라고 해보자. 그럼 AA와 Aa는 질병에 걸리고, aa만 질병에 걸리지 않는다.

AA 부모가 k명, Aa가 m명, aa가 n명 있을 때, 이들을 막 교배시키면 다음과 같은 조합이 나온다.

```
1) AA-AA: 모든 자식이 AA이므로 100% 질병
2) AA-Aa: 모든 자식이 AA 또는 Aa이므로 100% 질병
3) AA-aa: 모든 자식이 AA 또는 Aa이므로 100% 질병
4) Aa-AA: 2와 동일, 100% 질병
5) Aa-Aa: AA:Aa:aa = 1:2:1이므로 3/4 확률로 질병. 멘델의 1법칙 또는 우열의 법칙으로 유명하다.
6) Aa-aa: Aa:aa = 1:1이므로 1/2 확률로 질병
7) aa-AA: 3과 동일, 100% 질병
8) aa-Aa: 6과 동일, 100% 질병
9) aa-aa: 모든 자식이 aa이므로 100% 질병 없음
```

### 코딩

따라서 `total = k + m + n`이라고 했을 때 랜덤 교배의 결과로 나온 자식들이 우성 표현형일 확률은, 6명의 부모 중 부모 2명을 고르는 조합을 고려했을 때, 그 결과는 아래 코드와 같다. ~~사실 수식을 쓰려고 했는데, 수식이 너무 더러워져서 그냥 안썼다ㅎㅎ~~

이전과 다르게 input() 또는 iostream을 고려하지 않고 하나의 함수만 덩그러니 있는걸 볼 수 있는데, 이번 기회에 모든 계산을 C++용 biology 계산 모듈로 아키텍처 디자인해서 새로 리팩토링했고, 문제를 푸는 부분 자체는 헤더랑 다른 실행파일로 분리했기 때문이다. 자세한 내용은 [https://github.com/panda5176/ALSBIA](https://github.com/panda5176/ALSBIA) 여기서 보거나, 추후 해당 리팩토링 내용에 대한 글을 쓰도록 하겠다. ~~파이썬은 너무 쉬우니 설명을 생략한다..?~~

### 솔루션

#### Python

```py
def iprb(k, m, n):
    """Mendel's First Law"""
    p = k + m + n
    return round(
        k / p
        + m
        / p
        * (k / (p - 1) + (m - 1) / (p - 1) * (3 / 4) + n / (p - 1) * (1 / 2))
        + n / p * (k / (p - 1) + m / (p - 1) * (1 / 2)),
        5,
    )
```

#### C++

```c++
// Copyright 2021 panda5176

#include "include/algorithms.h"

float calc_mendels_1st_law(int homo_dominant, int hetero, int homo_recessive) {
  float homo_dominant_f = static_cast<float>(homo_dominant);
  float hetero_f = static_cast<float>(hetero);
  float homo_recessive_f = static_cast<float>(homo_recessive);

  float total_parents = homo_dominant_f + hetero_f + homo_recessive_f;
  float dominant_offspring
    = homo_dominant_f / total_parents
    + hetero_f / total_parents
      * (homo_dominant_f
        + (hetero_f - 1) * (3.0 / 4.0)
        + homo_recessive_f * (1.0 / 2.0))
      / (total_parents - 1.0)
    + homo_recessive_f / total_parents
      * (homo_dominant_f + hetero_f * (1.0 / 2.0))
      / (total_parents - 1.0);

  return dominant_offspring;
}
```
